library(Rcompadre)
library(Rage)
x <- cdb_fetch("compadre")
mpm <- matA(x)[1]
mpm
library(popdemo)
#Generation Time
?generation
#Generation Time
??generation
#Generation Time
popbio::generation.time(mpm)
mpm <- matA(x)[[1]]
#Generation Time
popbio::generation.time(mpm)
?kEntropy
mpmA <- matA(x)[[1]]
mpmU <- matU(x)[[1]]
mpmF <- matF(x)[[1]]
mpmC <- matC(x)[[1]]
#Generation Time
popbio::generation.time(mpm)
#Survivorship curve type (Keyfitz Entropy)
Rage::kEntropy(mpmU, startLife = 1, nSteps = 100, trapeze = TRUE)
#Degree of iteroparity (Demetrius Entropy)
Rage::dEntropy(mpmU, mpmF, startLife = 1, nSteps = 100)
#You can also calculate this JUST for sexual or clonal reproduction.
Rage::dEntropy(mpmU, mpmRep, startLife = 1, nSteps = 100)
#Degree of iteroparity (Demetrius Entropy)
mpmRep <- mpmF+mpmC #Add up clonality and sexual reproduction
#You can also calculate this JUST for sexual or clonal reproduction.
Rage::dEntropy(mpmU, mpmRep, startLife = 1, nSteps = 100)
#Life expectancy (from birth).
lifeExpectancy(mpmU, startLife = 1)
#Life time events
lifeTimeRepEvents(mpmU, mpmR, startLife = 1)
#You can also calculate this JUST for sexual or clonal reproduction.
Rage::dEntropy(mpmU, mpmR, startLife = 1, nSteps = 100)
#Degree of iteroparity (Demetrius Entropy)
mpmR <- mpmF+mpmC #Add up clonality and sexual reproduction
#You can also calculate this JUST for sexual or clonal reproduction.
Rage::dEntropy(mpmU, mpmR, startLife = 1, nSteps = 100)
#Life time events
lifeTimeRepEvents(mpmU, mpmR, startLife = 1)
#Probability of achieving reproductive maturity
temp$p
#Life time events
temp <- lifeTimeRepEvents(mpmU, mpmR, startLife = 1)
#Probability of achieving reproductive maturity
temp$p
#mean age at maturity (in the same units as the matrix population model sampling
#periodicity (usually years))
temp$La
#mean life expectancy conditional on entering the life cycle at the value of startLife
temp$meanLifeExpectancy
Rage::lifeExpectancy(mpmU, startLife = 1)
#Life time events
temp <- lifeTimeRepEvents(mpmU, mpmR, startLife = 1)
#remainingMatureLifeExpectancy = Life expectancy from mean maturity, calculated
#as meanLifeExpectancy - La. This value can be negative because both mean life
#expectancy and mean age at maturity are means of their respective
#distributions, and their distributions can indeed overlap
temp$remainingMatureLifeExpectancy
#R0 Net reproductive value
Rage::R0(mpmU,mpmR)
#Progressive growth
mpmA
lower.tri(mpmA)
mpmA[lower.tri(mpmA)]
!lower.tri(mpmA)
mpmA[!lower.tri(mpmA)] <-0
#Progressive growth
#THis is just the mean of the upper diagonal part of the matrix
mpmA
mean(mpmA)
#Extract the first matrix (replace [[1]] with [[n]] for the nth matrix)
mpmA <- matA(x)[[1]]
#Progressive growth
#THis is just the mean of the upper diagonal part of the matrix
mpmA
mean(mpmA[!lower.tri(mpmA)])
mean(mpmA[lower.tri(mpmA)])
lower.tri(mpmA)
mpmA[lower.tri(mpmA)]
#Progressive growth
#THis is just the mean of the upper diagonal part of the matrix
#This is the area of the matrix that denotes growth.
mean(mpmA[lower.tri(mpmA)])
#Retrogressive growth
mean(mpmA[upper.tri(mpmA)])
#Progressive growth
#THis is just the mean of the upper diagonal part of the matrix
#This is the area of the matrix that denotes growth.
colmeans(mpmA[lower.tri(mpmA)])
#Progressive growth
#THis is just the mean of the upper diagonal part of the matrix
#This is the area of the matrix that denotes growth.
colMeans(mpmA[lower.tri(mpmA)])
temp <- mpmA[mpmA[lower.tri(mpmA)]]
temp
#Progressive growth
#THis is just the mean of the upper diagonal part of the matrix
#This is the area of the matrix that denotes growth.
mpmA
temp <- mpmA[lower.tri(mpmA)]
temp
lower.tri(mpmA)
#Progressive growth
#THis is just the mean of the upper diagonal part of the matrix
#This is the area of the matrix that denotes growth.
temp <- mpmA
temp[!lower.tri(temp)] <- 0
temp
colMeans(temp)
popdemo::eigs{mpmA}
popdemo::eigs(mpmA)
popdemo::eigs(mpmA,what="ss")
weighted.mean(colMeans(temp),1)
weighted.mean(colMeans(temp),SSD)
colMeans(temp)
weighted.mean(as.vector(colMeans(temp)),SSD)
weighted.mean(x=colMeans(temp),w=SSD)
?weighted.mean
x<-as.vector(colMeans(temp))
x
weighted.mean(x=x,w=SSD)
length(x)
length(SSD)
SSD
SS <- popdemo::eigs(mpmA,what="ss")
SS
weighted.mean(x=x,w=SSD)
weighted.mean(x=x,w=SS)
#Progressive growth
#THis is just the mean of the upper diagonal part of the matrix
#This is the area of the matrix that denotes growth.
temp <- mpmA
temp[!lower.tri(temp)] <- 0
SS <- popdemo::eigs(mpmA,what="ss")
x<-colMeans(temp)
weighted.mean(x=x,w=SS)
temp[!upper.tri(temp)] <- 0
#Retrogressive growth
temp <- mpmA
temp[!upper.tri(temp)] <- 0
SS <- popdemo::eigs(mpmA,what="ss")
x<-colMeans(temp)
weighted.mean(x=x,w=SS)
#Retrogressive growth
temp <- mpmA
temp[!upper.tri(temp)] <- 0
temp
x<-colMeans(temp)
x
weighted.mean(x=x,w=SS)
temp <- mpmA
temp[!lower.tri(temp)] <- 0
SS <- popdemo::eigs(mpmA,what="ss")
x<-colMeans(temp)
weighted.mean(x=x,w=SS)
#Retrogressive growth
temp <- mpmA
temp[!upper.tri(temp)] <- 0
temp
SS <- popdemo::eigs(mpmA,what="ss")
x<-colMeans(temp)
weighted.mean(x=x,w=SS)
temp <- mpmU
temp[!lower.tri(temp)] <- 0 #zero out the upper triangle
SS <- popdemo::eigs(mpmA,what="ss") #calculate SSD
x<-colMeans(temp) #Calculate column means
#Now calculate the weighted mean (mean of colmeans, weighted by SSD)
weighted.mean(x=x,w=SS)
#Retrogressive growth
temp <- mpmU
temp[!upper.tri(temp)] <- 0 #zero out the lower triangle
SS <- popdemo::eigs(mpmA,what="ss") #calculate SSD
x<-colMeans(temp) #Calculate column means
#Now calculate the weighted mean (mean of colmeans, weighted by SSD)
weighted.mean(x=x,w=SS)
#Mean sexual reproduction
temp <- mpmA
temp
#Mean sexual reproduction
temp <- mpmF
temp
#Mean sexual reproduction
temp <- mpmF
x<-colMeans(temp)
SS <- popdemo::eigs(mpmA,what="ss") #calculate SSD
weighted.mean(x=x,w=SS)
